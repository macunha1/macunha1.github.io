[{"authors":["admin"],"categories":null,"content":"Hello!\nI\u0026rsquo;m Matheus Cunha (or just Macunha), a Software Engineer focused on Systems Analysis and Engineering, including DevOps and Data Engineering fields. Experienced architecting decentralized and highly available systems, with a demonstrated history of working as a consultant for many businesses in Brazil, helping them to be more future-proof and competitive in a highly changing market. Always looking for ways to improve, learn more and go further.\nAlso, I\u0026rsquo;m a open-source technology lover skilled in Linux, that writes code in:\n Java; Python; Go; JavaScript (Node.js); and sometimes Lua and Rust.  Using the following databases:\n PostgreSQL (for relational data); InfluxDB (including TICK stack) for timeseries; Elasticsearch (including ELK and EBK) for logging and searching; Hadoop (HDFS, S3 or Google Cloud Storage) for data warehousing; Kafka for message queueing; and Redis for caching and ephemeral information (sometimes message queuing too).  With Prometheus to monitor infrastructure being backed-up by InfluxData TICK stack, Ansible to have configuration management as code followed by Terraform, and Docker running in production, with Kubernetes.\nI\u0026rsquo;ve launched projects in all major clouds: AWS, Azure and GCP, including multi-cloud and hybrid-cloud with on-premises servers.\n:D\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1589734215,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://macunha.me/en/author/matheus-cunha/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/en/author/matheus-cunha/","section":"authors","summary":"Hello!\nI\u0026rsquo;m Matheus Cunha (or just Macunha), a Software Engineer focused on Systems Analysis and Engineering, including DevOps and Data Engineering fields.","tags":null,"title":"Matheus Cunha","type":"authors"},{"authors":null,"categories":["DevOps","Agile Manifesto"],"content":"Introduction Main benefits that a company generally expects and finds in the adoption of culture:\nFaster and Cheaper Releases Since releases will be continuous and frequent, deliverables will turn into small changes with the benefit of increasing speed in the development cycle (delivering always).\nImproved Operational support with quick fixed If there is a failure during delivery, the impact is minimal because the amount of modifications is small, just as the rollback is faster. Having a simple inspection and debugging.\nBetter Time-to-market (TTM) The software will be delivered much earlier when it\u0026rsquo;s still an MVP. Customers will be integrated as part of the development process, bringing insights and feedback to the development team. Thus allowing for a higher launch speed in the market.\nSuperior quality products As has been said before, early failures prevent defects from being delivered to production, because:\n Reduces the volume of defects in the product as a whole; Increases frequency of new features and releases; Appropriate development processes in teams, including automation.  Now we understood WHY, let\u0026rsquo;s talk about HOW Continuous releases (integration, delivery, deployment) Usually follows a code versioning approach (through Git) using specific branches for each environment (e.g.: feature branches with git flow).\nContinuous integration Automatic execution of unit tests, integration tests and code quality analysis against a git branch, to ensure that there was no disruption of the modified piece of code.\nContinuous delivery Packaging the software that is tested and approved, to deliver it somewhere that it is possible to use in a deploy later. Examples are libs delivered in repositories to be integrated into the code during the next update and code deploy.\nContinuous deployment Once you have completed all of the above steps, you can do automated deployments right in the environments, when the team is more confident about the tools they are testing, as well as the risk they\u0026rsquo;re taking and also understanding that there is a possibility of failure in a tests environment without worrying that it\u0026rsquo;s going to be divergent from production.\nConfiguration (and/or Infrastructure) as code To be able to test software with assertiveness, and to understand that it will transit between environments without changing behavior, it is essential that the configurations are also expressed in code. This allows the settings to be also versioned, following the code. Also guaranteeing a uniformity among the environments, which enables:\n Reduction in maintenance costs, having a single point to look at and understand the operation of the system; Easy to recreate the infrastructure, if it is necessary to move everything to another place, this can happen with a few manual interactions; Allows for a code review of infrastructure and configurations, which consequently brings a culture of collaboration in the development, sharing of knowledge and increases the democratization of the infra; Documentation as code, helping new team members get a faster warm up.  These points were well-stressed by the Heroku team and gave rise to the famous paper: [The Twelve-Factor App] (https://12factor.net/). It\u0026rsquo;s an excellent reading for the explanation of the benefits of configuration management.\nObservability, Monitoring, and self-healing At the end of the delivery process, the software must be monitored. Avoiding to wait for an external report of failures, ensuring that the actions are proactive rather than reactive.\nWith mature monitoring, it\u0026rsquo;s possible to create trigger against alerts, creating a self-healing system in which actions (scripts) are performed to fix known failures in the infrastructure so that everyone can sleep peacefully at night, without having to worry about the on-call schedule that makes you read some documentation at dawn. (If you have had experience with this, you know for sure how bad it is).\nScaling up only those cases that are extreme exceptions (mistakes not known/expected) in the process for the employee to act, ensuring higher health in operation.\nProcesses automation All processes that cause Muda should be addressed with automation, allowing people to work more quickly. Good examples of processes that are usually automated are:\n Deployment; Self-healing (system resilience in response to anomalies); Renewal of Certificates; Execution of tests (unitary, integration, functional, etc.); Monitoring (with auto-discovery); User Governance;  DevOps toolchain A combination of tools to facilitate the maintenance and operation of the system, with the flow:\n Note: Any similarity to the PDCA is pure certainty.\n  Plan: Project planning phase, in which feedbacks are collected for requirements survey, and backlog creation; Create: Creation of a deliverable (to validate a hypothesis), such as an MVP; Verify: Pass the deliverable to the test phase; Package: Package the build to be able to put it in some testing environment; Release: Deploy packaged deliverable; Configure: Perform the configuration of the deliverable in the testing environment, trying to get as close as possible to the twelve-factor app. Monitor: After deploying to the environment, track business metrics and infrastructure to ensure everything is working as expected.  Conclusion During the implementation of these techniques it is possible to observe improvements in the development process, the most notable gains are:\n Increase in team engagement; Knowledge sharing; Reduction of bottlenecks; More free time to do work that really matters (adds value to the user experience or generates impact); Greater confidence in delivering software.  ","date":1547244000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589734215,"objectID":"234c851ba757bb2bbbda260c3e11abe3","permalink":"https://macunha.me/en/post/2019/01/devops-benefits/","publishdate":"2019-01-11T22:00:00Z","relpermalink":"/en/post/2019/01/devops-benefits/","section":"post","summary":"Introduction Main benefits that a company generally expects and finds in the adoption of culture:\nFaster and Cheaper Releases Since releases will be continuous and frequent, deliverables will turn into small changes with the benefit of increasing speed in the development cycle (delivering always).","tags":["devops","culture","agile","lean"],"title":"DevOps: Benefits","type":"post"},{"authors":null,"categories":["DevOps","Agile Manifesto"],"content":"Introduction First of all, it\u0026rsquo;s all about agile.\nThe DevOps methodology was created on top of agile methods, to deliver a higher value inside software releases, automating feature release through pipelines, that can test hypothesis faster allowing higher adaptability using \u0026ldquo;fail-fast\u0026rdquo; approaches. Those changes are more cultural than technical, so it\u0026rsquo;s normal to see DevOps being called culture.\nThe implementation of DevOps happens through processes automation, having a strong sense of processes re-engineering inside the company. Comparing to the cultural change, the technical is easy to implement. Therefore the role that a \u0026ldquo;DevOps Engineer/Analyst\u0026rdquo; performs is very confusing, which enables many SysAdmins and Infra Analysts assuming the role of \u0026ldquo;DevOps.\u0026rdquo;\nLean is the basis of Agile Reality is not as happy as it sounds. After World War II, Japan was destroyed and under-resourced after losing the war. With a limited amount of resources, the country needed to reinvent itself and survive after a time of severe depression. During that time two guys gained attention inside a company that later gave its name after the methodology.\nThose guys were Eiji Toyoda and Taiichi Ohno, inside Toyota Motor Corporation. They\u0026rsquo;re the founders of the \u0026ldquo;Toyota production model\u0026rdquo; also known as Toyotism.\nToyota gave birth to Lean Lean teaches how to optimize the end-to-end process, focusing on processes that create value for customers. Bottlenecks in the process must be removed, and wasteful activities need to be identified and avoided. Both explained and defined by LEAN 3M: Muda, Mura, and Muri.\nAlso teaches to improve yourself day after day and always focus on quality through Kaizen (continuous improvement).\nJapanese culture truly believes that quality is the main objective to deliver value to customers since quality is what brings your clients back.\nKaizen A mindset that helps to look at each part of the process exclusively and think about the improvements. Involving the people who are part of the process, encourage the inclusion of these people in the decisions of change, since:\n It is much easier to accept a change when it is not imposed (top-down); There is a greater absorption of change by people when they\u0026rsquo;re included in the planning; The people who are involved in the process bring their concerns and suggestions, which contribute positively to the evolution of the change, making the idea more robust.  The process of defining improvements through Kaizen happens (usually) in the following order:\n Define data-driven objectives; Review the current state and develop an improvement plan; Implement improvement; Review the implementation and improve what does not work; Report the results and determine the items to be monitored.  This process is also called PDCA: Plain-Do-Control-Act, which is summarized in:\n Plan (develop the hypothesis); Do (experiment); Check (validate results); Act (refine the experiment and start over).  3M: Muda, Mura, Muri Muda (waste) Any activity that consumes time without adding value to the final consumer. e.g.:\n over-production; idle time in the process; products with a defect.  It\u0026rsquo;s important to remember that there are different levels of Muda that can be removed quickly or not, and the classification depends on the time for removal.\nAn example of a more time-consuming Muda is the discontinuation of legacy software that ends up with longer release cycles, causing teams to be idle, followed by an often long or manual test routine.\nMura (unevenness) Unevenness in operation, caused by activities that are very changeable and unpredictable, generating different results in all executions. e.g., the execution of tasks that were not well planned and ended up arriving with strict deadlines. The team runs in the rush, generating exhaustion, despair, and moreover, when finished leaves the people who have performed these tasks waiting (for feedback, or confirmation that it is completed).\nMuri (overload) Overburdening equipment or operators by requiring them to run at a higher or harder pace beyond the limit, to achieve some goal or expectation, causing fatigue and consequently failures during the process. These failures are usually human errors caused by fatigue during overwork.\nBack to Agile In 2000 a group of 17 people met at a resort in Oregon to talk about ideas that could improve the flow of software development. After a year of mature ideas, these people met again and published the ideas, which we now know as Agile Manifesto.\nMain points are:\nIndividuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan\nI will restrict the explanation of these points with the DevOps point of view, keeping on track (now).\nIndividuals and interactions over processes and tools\nFirst comes the individuals, they should receive the necessary tooling to work with, and then be empowered to do their jobs. Interactions between people are greatly encouraged, for sharing knowledge and also for facilitating creative flow within development teams.\nAn excellent example of interaction encouraged through DevOps is the code review habit. Considering that small parts of the software will be iterated and approved in the pipeline passing through different environments, automatically, the best way to prevent defects is through code review.\nThis habit brings benefits such as:\n Knowledge sharing; Observation of the problem from a different point of view; Team engagement; Lesser bugs.  Working software over comprehensive documentation\nHere\u0026rsquo;s a trick in \u0026ldquo;working software,\u0026rdquo; software that works is not code that compiles. The software that works is what meets the requirements of the user; i.e., the software that solves the problem and the pains of the user.\nAs the market is very dynamic, and evolves with high speed, often during the software development project the requirements change due to external factors. Therefore, knowing that it is not possible to predict all the elements, many \u0026ldquo;workarounds\u0026rdquo; are made during development and documented. Passing the responsibility to the user to handle the faults, and perform the workarounds, expending more effort than would be required to perform the tasks using the software.\n Deliver a working software frequently, ranging from a few weeks to a few months, considering shorter time-scale. - Agile Manifesto\n Encouraging as many deployments as possible, so that failures happen as early as possible, thus allowing their impact to be much less.\nFail-fast! Failures are understood and encouraged because it\u0026rsquo;s part of the mindset. Because:\n Only those who do make mistakes; Shit happens.  Therefore, it\u0026rsquo;s best for failures to occur early, while the cost of correction is still low. Failing a controlled testing environment allows the fix to be much faster (and cheaper) than it would if the fix were already in production.\nFor this approach to succeed, there is a premise that environments are production copies, or at least as close as possible. Otherwise, there will be behavioral changes in the software between the environments, making the test environment unfeasible.\nIf the environments are divergent, the promotion of bugs for production will be very frequent, causing late failures, which are expensive failures.\nCustomer collaboration over contract negotiation\nKnow your client! Including it in the process is the best approach to have working software. After iterating over deliverables, it\u0026rsquo;s essential to create a positive feedback loop with your client, bringing it as close as possible to the development of the tools that he/she is going to use.\nWe can describe this situation with:\n From point A it is possible to see only point B; From point B it is possible to see point C;  Therefore there is a great incentive for the software to be delivered in parts, continuously. Thus gathering user feedback on the next steps, following the concepts of evolutionary prototyping, which were widely publicized through The Lean Startup.\nThis point contrasts sharply with the previous one about continuous release, so that it is possible to present the prototype and evolve it throughout the project.\nLearn who your customer/consumer/user is, and whom you are making the software for, as this is the only way you can deliver value to that customer. An essential part of the software development process is to be empathic with user problems, and to truly understand what the problem is to be solved, and the result of the impact on software development (value creation for the user).\nResponding to change over following a plan\nRedesigning the requirements overtime is part of the job, and a necessary step to success. If you want to build something useful that is going to grow and have absorption, it\u0026rsquo;s a key feature to include your client in the implementation process.\nIt will be the only way to bring all the problems of the user to the table and create the best solution for all these problems because the user is the only person that knows the real challenges he faces in their routine dealing with software.\nWith continuous delivery of software along with monitoring results, the process of collecting feedback is much simpler and faster.\nDevOps, DevOps, DevOps With the popularization of DevOps, a lot of disagreement came out there followed by a significant confusion about the subject. It is very common to come across different interpretations of what is DevOps. There is a lot of euphemism in the area, and gourmetization on LinkedIn, with many SysAdmins calling themselves DevOps since they learned to code shell script inside Python.\nDo you want to keep reading? Here are the benefits of adopting DevOps techniques.\n","date":1547240400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589734215,"objectID":"1ea695d486767aac5f192dfd0ddf47d4","permalink":"https://macunha.me/en/post/2019/01/devops-genesis/","publishdate":"2019-01-11T21:00:00Z","relpermalink":"/en/post/2019/01/devops-genesis/","section":"post","summary":"Introduction First of all, it\u0026rsquo;s all about agile.\nThe DevOps methodology was created on top of agile methods, to deliver a higher value inside software releases, automating feature release through pipelines, that can test hypothesis faster allowing higher adaptability using \u0026ldquo;fail-fast\u0026rdquo; approaches.","tags":["devops","culture","agile","lean"],"title":"DevOps: The Genesis","type":"post"}]