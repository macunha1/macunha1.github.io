<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Product Engineering | It's me, Macunha!</title><link>https://macunha.me/en/category/product-engineering/</link><atom:link href="https://macunha.me/en/category/product-engineering/index.xml" rel="self" type="application/rss+xml"/><description>Product Engineering</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2021 Matheus Cunha</copyright><lastBuildDate>Sun, 28 Oct 2018 00:00:00 +0200</lastBuildDate><image><url>https://macunha.me/media/icon_hu176de0364afaeda8922c372b574c3cbf_6946_512x512_fill_lanczos_center_3.png</url><title>Product Engineering</title><link>https://macunha.me/en/category/product-engineering/</link></image><item><title>Insights from a perfectionist about Over-Engineering</title><link>https://macunha.me/en/post/2018/10/insights-from-a-perfectionist-about-over-engineering/</link><pubDate>Sun, 28 Oct 2018 00:00:00 +0200</pubDate><guid>https://macunha.me/en/post/2018/10/insights-from-a-perfectionist-about-over-engineering/</guid><description>&lt;h2 id="foreword">Foreword&lt;/h2>
&lt;p>NOTE: This article is an open letter for me to keep reminding myself about what
to prioritize when developing software, I am as much of a sinner in this aspect
as the next person.&lt;/p>
&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>We as software engineers are always trying to do our best when it comes to being
innovative, improving our systems to work better and faster, perhaps with a
better design, or a more comprehensive codebase. We all have some preference
when it comes to doing our bests which we try to achieve at all times.&lt;/p>
&lt;p>The main drive of this motivation is our necessity as &amp;ldquo;digital craftspeople&amp;rdquo; to
express ourselves through quality work, along with the personal realization we
feel by doing a great job, with great quality, that challenges us and takes
ourselves further. It&amp;rsquo;s motivating, isn&amp;rsquo;t it? Assuming risks and getting out of
the comfort zone is incredibly funny, our brain&amp;rsquo;s reward system goes crazy with
unpredictability.&lt;/p>
&lt;p>To help achieve that challenge, innovation, and quality in Software Engineering
we usually think that we need the best tools available, so we&amp;rsquo;ll have fewer
things to worry about, and can concentrate our efforts in the process of
creating great products. On top of that, having the best tools could improve our
quality of life (allowing us not to work under pressure, avoids overwork, and
also helps us to sleep better at night). Furthermore, &amp;ldquo;the right set of tools&amp;rdquo;
could even enhance our productivity through self-satisfaction with work,
everyone has their preoccupations and is willing to create something to be proud
of.&lt;/p>
&lt;p>Many times during the design and development of products we take unmeasured
solutions for a simple problem. After all, we want to have not just the right
set of tools, but the &lt;strong>best&lt;/strong> right? How can we be ground-breaking, innovative,
disruptive, and pick-your-buzzword-poison otherwise? Well, as Nathan Marz
(creator of Apache Storm) puts better in his &lt;a href="http://nathanmarz.com/blog/suffering-oriented-programming.html" target="_blank" rel="noopener">suffering-oriented programming&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>[…] don&amp;rsquo;t build technology unless you feel the pain of not having it. It applies
to the big, architectural decisions as well as the smaller everyday programming
decisions. Suffering-oriented programming greatly reduces risk by ensuring that
you&amp;rsquo;re always working on something important, and it ensures that you are
well-versed in a problem space before attempting a large investment.&lt;/p>
&lt;/blockquote>
&lt;p>This method describes a good way to think about LEAN and evolving products
through &lt;a href="https://dzone.com/articles/what-is-minimum-viable-product-and-how-to-build-it" target="_blank" rel="noopener">an MVP concept&lt;/a>, helping to keep track of what &lt;strong>really&lt;/strong> matters when it
comes to a good balance between Product and Engineering efforts.&lt;/p>
&lt;p>As we&amp;rsquo;re daily overfed with information, it&amp;rsquo;s easy to make mistakes trying to
choose the right set of tools to work with. From picking Frameworks to Operating
Systems, and even the cloud provider to host our systems and products. It&amp;rsquo;s OK
to make mistakes, we all have a great first impression about all choices we
could have done, if you read AWS or GCP documentation you&amp;rsquo;ll be impressed with
their magical solutions to your problems, where you can just throw everything in
(including your credit card), and everything will be fine, right? The magic
cloud will solve &lt;strong>all of your&lt;/strong> problems. Yeah, &lt;em>maybe&lt;/em>.&lt;/p>
&lt;h2 id="what-is-the-problem-i-am-trying-to-solve-here">What is the problem I am trying to solve here?&lt;/h2>
&lt;p>One good example of the current hype, when it comes to applications is Docker
containers and Kubernetes. Kubernetes is the open-source version of Google&amp;rsquo;s
Borg, a great Linux containers orchestration tool developed to orchestrate
applications on Google&amp;rsquo;s data center.&lt;/p>
&lt;p>Kubernetes is great, but the hype goes too far sometimes with companies running
even Production transactional databases on it, as well as entire monoliths and
Stateful services. At this point, we have to look back and ask ourselves: &amp;ldquo;What
problem I&amp;rsquo;m trying to solve here?&amp;rdquo;. Because, if you take a second look, these
decisions are kind of a &amp;ldquo;Hydra&amp;rdquo; solution, &amp;ldquo;for every head chopped off, the Hydra
would regrow two heads&amp;rdquo;, or even better: these solutions are creating more
problems, by trying to solve problems &lt;strong>that may not even exist&lt;/strong>.&lt;/p>
&lt;p>Yeah, Google orchestrated MySQL instance deployment using Borg. The first
&lt;a href="https://sre.google/sre-book/automation-at-google/" target="_blank" rel="noopener">version (POC) was released in 2008 and finished by 2009&lt;/a> at that time the revenue
of the Ad service was &lt;a href="https://www.statista.com/statistics/266249/advertising-revenue-of-google/" target="_blank" rel="noopener">estimated at USD ~22.9 Bi&lt;/a>. Ask yourself, do your database
serves a &lt;strong>USD 22.9 BILLION service&lt;/strong>? Do you &lt;em>really need&lt;/em> orchestration there?
Chances are, and let&amp;rsquo;s face it, &lt;a href="https://blog.bradfieldcs.com/you-are-not-google-84912cf44afb" target="_blank" rel="noopener">You Are Not Google&lt;/a>. This is an extreme example
but it serves to illustrate the main concept of &lt;em>suffering-oriented
programming&lt;/em>:&lt;/p>
&lt;blockquote>
&lt;p>[&amp;hellip;] don&amp;rsquo;t build technology unless you &lt;strong>feel the pain&lt;/strong> of not having it.&lt;/p>
&lt;/blockquote>
&lt;p>A nice quote from &amp;ldquo;You Are Not Google&amp;rdquo; to sink in:&lt;/p>
&lt;blockquote>
&lt;p>Don’t even start considering solutions until you &lt;strong>understand&lt;/strong> the problem. Your
goal should be to “solve” the problem mostly within the problem domain, not the
solution domain.&lt;/p>
&lt;/blockquote>
&lt;p>Otherwise, in case we insist on the inappropriate (not necessarily wrong)
solution, we&amp;rsquo;re going to spend some extra time dealing with the consequences
(i.e. chopping additional Hydra heads). Worth noting that dealing with the
consequences is not something bad, as long as you have the resources (time and
money) to invest into learning and rework, investing some resources into
inappropriate software solutions could even be seen as a way of training with
higher outcomes (learnings) than conferences, courses, and books. There is a lot
of lessons and knowledge to be extracted from these experiments.&lt;/p>
&lt;p>Learning from our experiences is the only path to success, and failures teach
best. Failures were also the motivation for writing this article to keep
reminding myself (:&lt;/p>
&lt;p>As Software Engineers the problem space analysis oftentimes fail due to an
underrated aspect, mostly unnoticed: on the other side of the line is a user of
this software.&lt;/p>
&lt;h2 id="and-guess-what">And guess what?&lt;/h2>
&lt;p>He doesn&amp;rsquo;t care if you&amp;rsquo;re running Elixir inside a container on Kubernetes, using
Container OS or Core OS, which you provisioned with your bare hands, and have
polished bit by bit to be XYZ ms faster than the Vanilla version. As long as you
respond to their requests, and &lt;strong>don&amp;rsquo;t break things&lt;/strong>.&lt;/p>
&lt;p>Innovation has nothing to do with the fact that you want to use cutting-edge
technology, and it&amp;rsquo;s not about how fast you spend money on those solutions
either. It&amp;rsquo;s about delivering value to your customers, and enrich their
experience from the interactions with your product.&lt;/p>
&lt;p>If you&amp;rsquo;re going through some orchestration problems, having 10+ micro-services
with some asynchronous task-based workers (e.g. Python&amp;rsquo;s Celery). Then, &lt;em>maybe&lt;/em>
it&amp;rsquo;s time to use Kubernetes. But, as an engineer you should know that the best
path is to put some solutions on the table, run some benchmarks and compare
them, so you&amp;rsquo;ll have data to help in your decision, and choose what&amp;rsquo;s the right
solution for your problem, &lt;strong>at the right time&lt;/strong>. We just have to keep asking
ourselves: &lt;em>&amp;ldquo;What is the problem I&amp;rsquo;m trying to solve here?&amp;quot;&lt;/em>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>There&amp;rsquo;s a quote from a great investor called Benjamin Graham that says:&lt;/p>
&lt;blockquote>
&lt;p>If you are looking for investments*, choose them the way you would buy
groceries, not the way you would buy perfume.
&amp;ndash; Graham, The Intelligent Investor (1973)&lt;/p>
&lt;/blockquote>
&lt;p>We should carefully look to where we&amp;rsquo;re going with our choices. So we don&amp;rsquo;t
overspend and keep things going for more time, thus we go further.&lt;/p>
&lt;p>NOTE: The original text is: &amp;ldquo;If you are shopping for common stocks [&amp;hellip;]&amp;rdquo;. But, as
a Software Engineer, I just switched the syntax so we could adapt it to more
use-cases (:&lt;/p>
&lt;p>I learned from my own experience that over-engineered decisions end up bringing
more pain than solving problems, and it currently happens through early
improvements on the system, timing really matters. Many times we try to solve
all problems at once (even those we don&amp;rsquo;t have), and it brings more problems,
like high costs of maintenance and infrastructure, or under-utilization of the
resources.&lt;/p>
&lt;p>Sooner or later, the Over-Engineering bill will come as Hydra heads keep growing
up accumulating technical debt. Be mindful when analyzing the problem space,
pick the right tool for the job that eases your real pain (not the imaginary
one).&lt;/p></description></item></channel></rss>