<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Terraform | It's me, Macunha!</title><link>https://macunha.me/en/category/terraform/</link><atom:link href="https://macunha.me/en/category/terraform/index.xml" rel="self" type="application/rss+xml"/><description>Terraform</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2021 Matheus Cunha</copyright><lastBuildDate>Wed, 11 Aug 2021 00:00:00 +0200</lastBuildDate><image><url>https://macunha.me/media/icon_hu176de0364afaeda8922c372b574c3cbf_6946_512x512_fill_lanczos_center_2.png</url><title>Terraform</title><link>https://macunha.me/en/category/terraform/</link></image><item><title>Real-life Terraform Refactoring Guide</title><link>https://macunha.me/en/post/2021/08/real-life-terraform-refactoring-guide/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0200</pubDate><guid>https://macunha.me/en/post/2021/08/real-life-terraform-refactoring-guide/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>As reality hits, the unavoidable fact of dealing with a hard-to-manage Terraform
&lt;a href="https://en.wikipedia.org/wiki/Big%5Fball%5Fof%5Fmud" target="_blank" rel="noopener">Big ball of mud&lt;/a> code base comes in. There is no way around natural growth and
evolution of code bases and the design flaws that come with it. Our Agile
mindset is to &lt;a href="https://www.brainyquote.com/quotes/mark%5Fzuckerberg%5F453439" target="_blank" rel="noopener">&amp;ldquo;move fast and break things&amp;rdquo;&lt;/a>, implement something as simple as
possible and let the design decisions for the next iterations (if any).&lt;/p>
&lt;p>Refactoring Terraform code is actually as natural as developing it, time and
time again you will be faced with a situation where a better structure or
organization can be achieved, maybe you want to upgrade from a home-made module
to an open-source/community alternative, maybe you just want to segregate your
resources into different states to speed-up development. Regardless of the goal,
once you get into it, you will realize that Terraform code refactoring is
actually a basic missing step on the development process that no one told you
before.&lt;/p>
&lt;p>As the &lt;a href="http://nathanmarz.com/blog/suffering-oriented-programming.html" target="_blank" rel="noopener">Suffering-Oriented Programming&lt;/a> mantra dictates:&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;First make it possible. Then make it beautiful. Then make it fast.&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>So, time to make the Terraform code beautiful!&lt;/p>
&lt;h2 id="how-to-break-a-big-ball-of-mud-strangle-it">How to break a big ball of mud? STRANGLE IT&lt;/h2>
&lt;p>&lt;code>&amp;lt;joke&amp;gt;&lt;/code> Martin Fowler has already written everything there is to write about
(early 2000s) DevOps, Agile, and Software Development. Therefore, we could
reference Martin Fowler for virtually anything Software related &lt;code>&amp;lt;/joke&amp;gt;&lt;/code>, but
really, the &lt;a href="https://martinfowler.com/books/refactoring.html" target="_blank" rel="noopener">Refactoring book&lt;/a> is &lt;strong>THE&lt;/strong> reference on this subject.&lt;/p>
&lt;p>Martin Fowler shared the &lt;a href="https://martinfowler.com/bliki/StranglerFigApplication.html" target="_blank" rel="noopener">Stangler (Fig) Pattern&lt;/a>, which describes a strategy to
refactor a legacy code base by re-implementing the same features (sometimes even
the bugs) on another application.&lt;/p>
&lt;blockquote>
&lt;p>[&amp;hellip;] the huge strangler figs. They seed in the upper branches of a tree and
gradually work their way down the tree until they root in the soil. Over many
years they grow into fantastic and beautiful shapes, meanwhile strangling and
killing the tree that was their host.&lt;/p>
&lt;p>This metaphor struck me as a way of describing a way of doing a rewrite of an
important system.&lt;/p>
&lt;/blockquote>
&lt;p>In this document we are going to follow the same idea:&lt;/p>
&lt;ol>
&lt;li>implement the same feature on a different &lt;a href="https://www.terraform-best-practices.com/key-concepts#composition" target="_blank" rel="noopener">Terraform composition&lt;/a>;&lt;/li>
&lt;li>migrate the Terraform state;&lt;/li>
&lt;li>delete (kill) the previous implementation.&lt;/li>
&lt;/ol>
&lt;h2 id="the-mono-repository--monorepo--approach-to-legacy">The mono-repository (monorepo) approach to Legacy&lt;/h2>
&lt;p>Let&amp;rsquo;s suppose that your Terraform code base is versioned in a single repository
(a.k.a. monorepo), following the random structure displayed below (just to help
illustrate)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">.
├── modules/ # Definition of TF modules used by underlying compositions
├── global/ # Resources that aren&amp;#39;t restricted to one environment
│   ├── aws/
├── production/ # Production environment resources
│   └── aws/
└── staging/ # Staging environment resources
└── aws/
&lt;/code>&lt;/pre>&lt;/div>&lt;p>On this example each directory corresponds to a Terraform state. In order to
apply changes you have to walk to a path and execute &lt;code>terraform&lt;/code>.&lt;/p>
&lt;p>The structure on this example repository was created a few hypothetical years
ago when the number of existing microservices and resources (DB, message queues,
etc) was significantly smaller. At the time, it was feasible to keep Terraform
definitions together because it was easier to maintain, Cloud resources were
managed with one-shot!&lt;/p>
&lt;p>As the time went by, the number of Products and the team grew, and engineers
started facing concurrency issues: Terraform lock executions on a shared storage
when someone else is running &lt;code>terraform apply&lt;/code> as well as a general slowness on
&lt;strong>every execution&lt;/strong> since the number of data sources to sync is frightening.&lt;/p>
&lt;p>A mono-repository approach is not necessarily bad, versioning is actually
simpler when performed in one single repository. Ideally, there won&amp;rsquo;t be many
changes on the scale of GiB meaning that it is safe to proceed on this one &lt;em>as
long as the Terraform remote states are divided&lt;/em>.&lt;/p>
&lt;h3 id="splitting-the-modules-sub-path-to-its-own-repository">Splitting the &lt;code>modules&lt;/code> sub-path to its own repository&lt;/h3>
&lt;p>One thing to mention though is the &lt;code>modules&lt;/code> sub-path, this one could be stored
in a different git repository to leverage its own versioning. Since Terraform
modules and its implementations don&amp;rsquo;t always evolve in the same pace, keeping
two distinct version trees is beneficial. Additionally, a separated repository
for Terraform modules allows the specification of &amp;ldquo;pinned versions&amp;rdquo;, e.g.:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">module &lt;span style="color:#e6db74">&amp;#34;aws_main_vpc&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;git::https://github.com/terraform-aws-modules/terraform-aws-vpc.git?ref=2ca733d&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># Note the ref=${GIT_REVISION_DIGEST}&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>That reference for a module&amp;rsquo;s version should always be specified, regardless if
it comes from an internal/private repository or public. When you specify the
version, you are ensuring reproducibility.&lt;/p>
&lt;p>Therefore, let&amp;rsquo;s move the &lt;code>modules&lt;/code> sub-path to another git repository,
following instructions from &lt;a href="https://stackoverflow.com/questions/359424/detach-move-subdirectory-into-separate-git-repository/17864475#17864475" target="_blank" rel="noopener">this StackOverflow answer&lt;/a> so that the git commit
history is preserved:&lt;/p>
&lt;h4 id="0-dot">0.&lt;/h4>
&lt;p>Walk to the monorepo path and create a branch from the commits at
&lt;code>monorepo/modules&lt;/code> path&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">MAIN_BIGGER_REPO&lt;span style="color:#f92672">=&lt;/span>/path/to/the/monorepo
cd &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>MAIN_BIGGER_REPO&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
git subtree split -P modules -b refact-modules
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="1-dot">1.&lt;/h4>
&lt;p>Create the new repository&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">mkdir /path/to/the/terraform-modules &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cd $_
git init
git pull &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>MAIN_BIGGER_REPO&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> refact-modules
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-dot">2.&lt;/h4>
&lt;p>Link the new repository to your remote Git (server)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git remote add origin &amp;lt;git@git.com:user/terraform-modules.git&amp;gt;
git push -u origin master
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-dot">3.&lt;/h4>
&lt;p>[OPTIONAL] Cleanup inside &lt;code>$MAIN_BIGGER_REPO&lt;/code>, if desired&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">cd &lt;span style="color:#e6db74">${&lt;/span>MAIN_BIGGER_REPO&lt;span style="color:#e6db74">}&lt;/span>
git rm -rf modules
git filter-branch --prune-empty &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> --tree-filter &lt;span style="color:#e6db74">&amp;#34;rm -rf modules&amp;#34;&lt;/span> -f HEAD
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="let-s-start-strangling-the-repository">Let&amp;rsquo;s start strangling the repository&lt;/h3>
&lt;p>Now that a substantial piece of code was moved somewhere else, it is time to
put the &lt;a href="https://martinfowler.com/bliki/StranglerFigApplication.html" target="_blank" rel="noopener">Stangler (Fig) Pattern&lt;/a> in practice.&lt;/p>
&lt;p>Move all the existing content as-is to the &lt;code>legacy&lt;/code> sub-path, keeping the same
repository and change history (commits). It also allows applying the &lt;code>legacy&lt;/code>
code as it used to be from one of those paths.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">.
└── legacy
├── global
│   └── aws
├── production
│   └── aws
└── staging
└── aws
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once the content is moved to legacy, the idea is to follow the &lt;a href="https://www.oreilly.com/library/view/97-things-every/9780596809515/ch08.html" target="_blank" rel="noopener">Boy Scout rule&lt;/a>
in order to strangle the &lt;code>legacy&lt;/code> content little by little (unless you are
really committed to migrating it all at once, which is going to be exhaustive).&lt;/p>
&lt;p>The Boy Scout rule goes like:&lt;/p>
&lt;ol>
&lt;li>every time a task that involves deprecated code appears, we implement it on
&lt;a href="../stdout/blog/2021/03/terraform-best-practices.org">the new structure&lt;/a>;&lt;/li>
&lt;li>import the Terraform state to keep the Cloud resources that a given code
represents/describes;&lt;/li>
&lt;li>remove the state and the code from &lt;code>legacy&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>Until there is nothing left inside &lt;code>legacy&lt;/code> (or there are only unused
resources/left-behinds that could be destroyed/garbage collected either way).&lt;/p>
&lt;h4 id="import-state-remove-state-and-code-from-what-where">Import state? Remove state and code from what? Where?&lt;/h4>
&lt;p>That will depend on the kind of resource we are migrating from the remote state,
on the bottom of each &lt;code>resource&lt;/code> on Terraform&amp;rsquo;s provider documentation you can
find a reference command to import existing resources into your Terraform code
specification. e.g.: &lt;a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/db%5Finstance#import" target="_blank" rel="noopener">AWS RDS DB instance&lt;/a>.&lt;/p>
&lt;p>Suppose we want to replace the code of the AWS RDS Aurora defined in
&lt;code>production/aws&lt;/code> and then re-implement the same using &lt;a href="https://github.com/terraform-aws-modules/terraform-aws-rds-aurora" target="_blank" rel="noopener">the community module&lt;/a>.
After creating the corresponding sub-path to the monorepo according to your
preference, provisioning the bucket and initializing the Terraform &lt;code>backend&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>implement the definition of the community module
&lt;a href="https://github.com/terraform-aws-modules/terraform-aws-rds-aurora" target="_blank" rel="noopener">github.com/terraform-aws-modules/terraform-aws-rds-aurora&lt;/a> with the closest
parameters from the existing one; e.g.:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">module &lt;span style="color:#e6db74">&amp;#34;aws_aurora_main_cluster&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;terraform-aws-modules/rds-aurora/aws&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; 5.2&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># ...&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>import the Terraform states from the previous (existing) cluster&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">terraform import &lt;span style="color:#e6db74">&amp;#39;aws_aurora_main_cluster.aws_rds_cluster.this[0]&amp;#39;&lt;/span> main-database-name
terraform import &lt;span style="color:#e6db74">&amp;#39;aws_aurora_main_cluster.aws_rds_cluster_instance.this[0]&amp;#39;&lt;/span> main-database-instance-name-01
terraform import &lt;span style="color:#e6db74">&amp;#39;aws_aurora_main_cluster.aws_rds_cluster_instance.this[1]&amp;#39;&lt;/span> main-database-instance-name-02
&lt;span style="color:#75715e"># ...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>then if you haven&amp;rsquo;t yet and would like to &amp;ldquo;match reality&amp;rdquo; between the
existing and the specified resource, run &lt;code>terraform plan&lt;/code> a few times and
adjust the parameters until Terraform reports:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">No changes. Your infrastructure matches the configuration.
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>last but not least, remove the corresponding resources from the &lt;code>legacy&lt;/code>
Terraform state so that it doesn&amp;rsquo;t try to keep track of the changes and also
don&amp;rsquo;t try to destroy once the resource definition is no longer in that code
base:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># Hypothetical name of the resource inside production/aws/main.tf&lt;/span>
terraform state rm aws_rds_cluster.default &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#e6db74">&amp;#39;aws_rds_cluster_instance.default[0]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;aws_rds_cluster_instance.default[1]&amp;#39;&lt;/span>
&lt;span style="color:#75715e"># ...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>once that is performed, feel free to remove the corresponding resource&amp;rsquo;s
definition from the &lt;code>legacy&lt;/code> code.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">resource &lt;span style="color:#e6db74">&amp;#34;aws_rds_cluster&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span> {
&lt;span style="color:#75715e"># ...&lt;/span>
}
resource &lt;span style="color:#e6db74">&amp;#34;aws_rds_cluster_instance&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span> {
count &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>number_of_database_instances
&lt;span style="color:#75715e"># ...&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol></description></item><item><title>Terraform: Atomic Design</title><link>https://macunha.me/en/post/2021/06/terraform-atomic-design/</link><pubDate>Tue, 29 Jun 2021 00:00:00 +0200</pubDate><guid>https://macunha.me/en/post/2021/06/terraform-atomic-design/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>Following &lt;a href="https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/" target="_blank" rel="noopener">The Pragmatic Programmer&lt;/a> mantra, I do my best to &amp;hellip;&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Learn at least one new language every year.&lt;/strong> Different languages solve the same
problems in different ways. By learning several different approaches, you can
help broaden your thinking and avoid getting stuck in a rut.&lt;/p>
&lt;/blockquote>
&lt;p>Not necessarily to show it off or to be capable of talking about random
technologies, but to expand and train my problem-solving skills, to get new
perspectives when approaching a challenge.&lt;/p>
&lt;p>We might not notice it but when we learn (or have learned) to code we aren&amp;rsquo;t
just learning to type some characters that a compiler/interpreter can
understand, it is a new way of thinking, a new way of breaking down solutions
(into sequential steps).&lt;/p>
&lt;blockquote>
&lt;p>It doesn&amp;rsquo;t matter whether you ever use any of these technologies on a project,
or even whether you put them on your resume. The process of learning will expand
your thinking, opening you to new possibilities and new ways of doing things.
The cross-pollination of ideas is important;&lt;/p>
&lt;/blockquote>
&lt;p>As someone who works intensively with infrastructure components (servers,
databases, Kubernetes, CI/CD, etc) I aimed for something completely different
this year. Something that stands on &lt;em>a whole different spectrum&lt;/em> of the system,
this year I decided to learn &lt;a href="https://flutter.dev/" target="_blank" rel="noopener">Flutter&lt;/a>.&lt;/p>
&lt;p>In-a-nutshell, Flutter is a better React Native. A framework that enables
implementation of GUI applications for multiple platforms with a single code
base.&lt;/p>
&lt;p>Then it reminded me a discussion I had with a friend in the past about React
components and the &lt;a href="https://bradfrost.com/blog/post/atomic-web-design/" target="_blank" rel="noopener">Atomic Design&lt;/a> methodology, which helps to structure web
components into modules.&lt;/p>
&lt;p>In the Atomic Design methodology, the granularity of modules is distinguished by
using chemistry inspired names: atoms, molecules and organisms.&lt;/p>
&lt;p>Then the connection of the ideas from&lt;/p>
&lt;ul>
&lt;li>Pragmatic Programmer&amp;rsquo;s cross-pollination to&lt;/li>
&lt;li>Atomic Design (on Flutter components) to&lt;/li>
&lt;li>Terraform modules&lt;/li>
&lt;/ul>
&lt;p>came almost like a thunderbolt, striking me with this insight when I was working
with a huge legacy Terraform code base refactoring with lots of code duplication
(read: copy+paste, &amp;ldquo;we fix it later&amp;rdquo;, then the author quits the company and
never fix anything).&lt;/p>
&lt;p>Although initially proposed as a Web UI methodology, Infrastructure as Code
tools such as Terraform that makes heavy usage of modules can benefit from
Atomic Design to improve its code reusability and massively reduce duplication.&lt;/p>
&lt;h2 id="details">Details&lt;/h2>
&lt;p>The Atomic Design methodology proposes five distinct levels, listed from the
finest to the thickest granularity:&lt;/p>
&lt;ol>
&lt;li>Atom;&lt;/li>
&lt;li>Molecules;&lt;/li>
&lt;li>Organisms;&lt;/li>
&lt;li>Templates;&lt;/li>
&lt;li>Pages.&lt;/li>
&lt;/ol>
&lt;p>However, to extract the gist, we&amp;rsquo;ll only be focusing on Atoms, Molecules, and
Organisms (from 1. to 3.). Templates and Pages are too specialized for Web UI
development.&lt;/p>
&lt;h3 id="atoms">Atoms&lt;/h3>
&lt;p>Atoms represent the finest grain in terms of granularity in the design. When
referring specifically to its implementation in Terraform a &lt;code>resource&lt;/code> and a
small scoped single-purpose &lt;code>module&lt;/code> could be used interchangeably.&lt;/p>
&lt;p>Sometimes the idea of turning a simple resource into a module makes sense to
ease parameterization and reusability, especially when it is necessary to parse
inputs. Although, due to its extreme limited scope it might not look attractive
to convert the &lt;code>resource&lt;/code> into a &lt;code>module&lt;/code> at first sight, on the long run it
pays off to do so in order to achieve scalability and reproducibility.&lt;/p>
&lt;p>e.g.:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">data &lt;span style="color:#e6db74">&amp;#34;aws_route53_zone&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span> {
zone_id &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>zone_id
name &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>zone_name
}
resource &lt;span style="color:#e6db74">&amp;#34;aws_route53_record&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span> {
zone_id &lt;span style="color:#f92672">=&lt;/span> data&lt;span style="color:#f92672">.&lt;/span>aws_route53_zone&lt;span style="color:#f92672">.&lt;/span>default&lt;span style="color:#f92672">.&lt;/span>zone_id
name &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>name
ttl &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>ttl
type &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>record_type
records &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>records
dynamic &lt;span style="color:#e6db74">&amp;#34;alias&amp;#34;&lt;/span> {
for_each &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>var&lt;span style="color:#f92672">.&lt;/span>alias&lt;span style="color:#f92672">]&lt;/span>
content {
name &lt;span style="color:#f92672">=&lt;/span> each&lt;span style="color:#f92672">.&lt;/span>value&lt;span style="color:#f92672">.&lt;/span>name
zone_id &lt;span style="color:#f92672">=&lt;/span> try(each&lt;span style="color:#f92672">.&lt;/span>value&lt;span style="color:#f92672">.&lt;/span>zone_id, data&lt;span style="color:#f92672">.&lt;/span>aws_route53_zone&lt;span style="color:#f92672">.&lt;/span>default&lt;span style="color:#f92672">.&lt;/span>zone_id)
evaluate_target_health &lt;span style="color:#f92672">=&lt;/span> lookup(
each&lt;span style="color:#f92672">.&lt;/span>value,
&lt;span style="color:#e6db74">&amp;#34;evaluate_target_health&amp;#34;&lt;/span>,
&lt;span style="color:#66d9ef">false&lt;/span>,
)
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this case, even though &lt;code>aws_route53_record&lt;/code> is a simple resource that might
feel too narrow in scope to write a module, the implementation of the module
allows to bundle the AWS Route53 Zone data source together, which helps to:&lt;/p>
&lt;ol>
&lt;li>provide a simpler contract by allowing the usage of &lt;code>zone_name&lt;/code> alone;&lt;/li>
&lt;li>validate the &lt;code>zone_name&lt;/code> input, ensuring that a given &lt;code>zone_name&lt;/code> corresponds to an
actual &lt;strong>existing and valid&lt;/strong> AWS resource;&lt;/li>
&lt;li>same goes to &lt;code>zone_id&lt;/code>, which will feel (and oftentimes, be) redundant,
&lt;em>when&lt;/em> specified as an input Terraform will read the data from AWS API
ensuring consistency.&lt;/li>
&lt;/ol>
&lt;p>e.g.:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">module &lt;span style="color:#e6db74">&amp;#34;awesome_dns_fqdn&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;path/to/modules/atoms/aws_route53_record&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; 1.0&amp;#34;&lt;/span>
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;record.example.com&amp;#34;&lt;/span>
zone_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;example.com.&amp;#34;&lt;/span>
record_type &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;CNAME&amp;#34;&lt;/span>
records &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1.2.3.4&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hence, resources and modules are sometimes interchangeable as they deliver the
same outcome for the finest resources' granularity.&lt;/p>
&lt;h3 id="molecules">Molecules&lt;/h3>
&lt;p>When groups of atoms are bounded together, they create a molecule which is the
smallest fundamental unit of a compound.&lt;/p>
&lt;p>Contrary to the original Atomic Design for Web UI, in Terraform, Atoms are
useful on their own. However, the usage of atoms comes with a high price on
scalability: code duplication. Actually, duplication is an understatement, it is
more like code exponentiation (more on this later).&lt;/p>
&lt;h4 id="implementation-example">Implementation example&lt;/h4>
&lt;p>Suppose we are creating a public facing API Gateway that needs a DNS record.&lt;/p>
&lt;p>Let&amp;rsquo;s compose it with the previous example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">data &lt;span style="color:#e6db74">&amp;#34;aws_route53_zone&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span> {
name &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>zone_name
}
module &lt;span style="color:#e6db74">&amp;#34;awesome_api_gateway_certificate&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;terraform-aws-modules/acm/aws&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; v3.0&amp;#34;&lt;/span>
domain_name &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>domain_name
zone_id &lt;span style="color:#f92672">=&lt;/span> data&lt;span style="color:#f92672">.&lt;/span>aws_route53_zone&lt;span style="color:#f92672">.&lt;/span>default&lt;span style="color:#f92672">.&lt;/span>zone_id
wait_for_validation &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
}
module &lt;span style="color:#e6db74">&amp;#34;awesome_api_gateway&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;terraform-aws-modules/apigateway-v2/aws&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; 1.0&amp;#34;&lt;/span>
name &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>api_gateway_name
description &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>api_gateway_description
protocol_type &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;HTTP&amp;#34;&lt;/span>
cors_configuration &lt;span style="color:#f92672">=&lt;/span> {
allow_headers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;content-type&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;x-amz-date&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;authorization&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;x-api-key&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;x-amz-security-token&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;x-amz-user-agent&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">]&lt;/span>
allow_methods &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
allow_origins &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
}
&lt;span style="color:#75715e"># Custom domain&lt;/span>
domain_name &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>domain_name
domain_name_certificate_arn &lt;span style="color:#f92672">=&lt;/span> module&lt;span style="color:#f92672">.&lt;/span>awesome_api_gateway_certificate&lt;span style="color:#f92672">.&lt;/span>acm_certificate_arn
&lt;span style="color:#75715e"># Routes and integrations&lt;/span>
integrations &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>api_gateway_integrations
}
module &lt;span style="color:#e6db74">&amp;#34;awesome_dns_fqdn&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;path/to/modules/atoms/aws_route53_record&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; 1.0&amp;#34;&lt;/span>
name &lt;span style="color:#f92672">=&lt;/span> var&lt;span style="color:#f92672">.&lt;/span>domain_name
zone_id &lt;span style="color:#f92672">=&lt;/span> data&lt;span style="color:#f92672">.&lt;/span>aws_route53_zone&lt;span style="color:#f92672">.&lt;/span>default&lt;span style="color:#f92672">.&lt;/span>zone_id
record_type &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;CNAME&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">alias&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
name &lt;span style="color:#f92672">=&lt;/span> module&lt;span style="color:#f92672">.&lt;/span>awesome_api_gateway&lt;span style="color:#f92672">.&lt;/span>apigatewayv2_domain_name_configuration&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">].&lt;/span>target_domain_name
zone_id &lt;span style="color:#f92672">=&lt;/span> module&lt;span style="color:#f92672">.&lt;/span>awesome_api_gateway&lt;span style="color:#f92672">.&lt;/span>apigatewayv2_domain_name_configuration&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">].&lt;/span>hosted_zone_id
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This helps illustrating an example in which the &lt;code>aws_route53_record&lt;/code> atom could
be easily replaced with its equivalent resource and it would still provide the
&lt;strong>same&lt;/strong> outcome.&lt;/p>
&lt;p>Commonly it is possible to use &lt;code>module&lt;/code> and &lt;code>resource&lt;/code> interchangeably as Atoms,
the decision of whether or not to implement a &lt;code>module&lt;/code> is ultimately defined by
the need of parsing and/or validating the inputs (variables).&lt;/p>
&lt;h4 id="usage-example">Usage example&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">module &lt;span style="color:#e6db74">&amp;#34;awesome_lambda&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;path/to/modules/molecules/aws_lambda_function&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; 1.0&amp;#34;&lt;/span>
function_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;awesome&amp;#34;&lt;/span>
description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;An Awesome lambda function for the Awesome API Gateway&amp;#34;&lt;/span>
handler &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;index.lambda_handler&amp;#34;&lt;/span>
runtime &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;python3.8&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># Incomplete implementation, don&amp;#39;t use this on production&lt;/span>
}
module &lt;span style="color:#e6db74">&amp;#34;another_awesome_lambda&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;path/to/modules/molecules/aws_lambda_function&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; 1.0&amp;#34;&lt;/span>
function_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;awesome&amp;#34;&lt;/span>
description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;An Awesome lambda function for the Awesome API Gateway&amp;#34;&lt;/span>
handler &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;index.lambda_handler&amp;#34;&lt;/span>
runtime &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;python3.8&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># Incomplete implementation, don&amp;#39;t use this on production&lt;/span>
}
module &lt;span style="color:#e6db74">&amp;#34;awesome_api_gateway&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;path/to/modules/molecules/aws_api_gateway&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; 1.0&amp;#34;&lt;/span>
domain_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;record.example.com&amp;#34;&lt;/span>
zone_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;example.com.&amp;#34;&lt;/span>
api_gateway_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;awesome-api-gateway&amp;#34;&lt;/span>
api_gateway_description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;An Awesome API Gateway&amp;#34;&lt;/span>
api_gateway_integrations &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#e6db74">&amp;#34;POST /&amp;#34;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
lambda_arn &lt;span style="color:#f92672">=&lt;/span> module&lt;span style="color:#f92672">.&lt;/span>awesome_lambda&lt;span style="color:#f92672">.&lt;/span>function_arn
payload_format_version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;2.0&amp;#34;&lt;/span>
}
&lt;span style="color:#e6db74">&amp;#34;$default&amp;#34;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
lambda_arn &lt;span style="color:#f92672">=&lt;/span> module&lt;span style="color:#f92672">.&lt;/span>another_awesome_lambda&lt;span style="color:#f92672">.&lt;/span>function_arn
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As you probably have already realized, when the level of abstraction goes up
(e.g. from atom to molecule) the module implementation is in itself a good
implementation example (i.e. as in &lt;a href="https://github.com/terraform-aws-modules/terraform-aws-lambda/blob/master/main.tf" target="_blank" rel="noopener">community modules examples&lt;/a>).&lt;/p>
&lt;p>They help to self-document the usage and implementation of a given module and
through generic implementations it allows us to have multiple molecules
implementing multiple distinct use-cases. e.g.:&lt;/p>
&lt;ol>
&lt;li>Public API Gateway with DNS record + TLS certificate;&lt;/li>
&lt;li>Public API Gateway v1, no DNS record;&lt;/li>
&lt;li>Private API Gateway.&lt;/li>
&lt;/ol>
&lt;p>Why would we chose to implement multiple times the Atom modules in order to
create multiple distinct use-cases? We are getting closer to the &lt;em>code
exponentiation&lt;/em> problem and solution proposal. Can you feel it?&lt;/p>
&lt;h3 id="organisms">Organisms&lt;/h3>
&lt;p>Going further, the &lt;a href="#usage-example">example of composition for molecules&lt;/a> can have its hard-coded
values turned into variables in order to compose an Organism, which can
facilitate the implementation of the same definition across different
environments. Thus, achieving reproducibility as well as the &lt;a href="https://12factor.net/dev-prod-parity" target="_blank" rel="noopener">Factor X.&lt;/a> of the
Twelve Factor App.&lt;/p>
&lt;p>However, it is important to note that the level of abstraction between Organisms
and Molecules can be easily confused or misunderstood. Generally speaking, as a
rule of thumb an Organism is the composition of Molecules that allow parameterization for
business or domain-specific logic (e.g. the actual &lt;code>awesome_api&lt;/code> configuration).
Therefore, in comparison with the previous, Organisms (usually) have a lower
level of generalization since they are business-specialized modules.&lt;/p>
&lt;p>Iterating over our implementation example, the Organism would implement the
&lt;code>awesome_api&lt;/code>, creating the following resources:&lt;/p>
&lt;ul>
&lt;li>AWS Lambda function;&lt;/li>
&lt;li>AWS API Gateway;&lt;/li>
&lt;li>TLS Certificate on AWS ACM;&lt;/li>
&lt;li>DNS record on AWS Route53.&lt;/li>
&lt;/ul>
&lt;p>By implementing the previous examples as organisms we:&lt;/p>
&lt;ol>
&lt;li>reduce the amount of boilerplate code;&lt;/li>
&lt;li>foster reusability of modules;&lt;/li>
&lt;li>provide a simple interface for non-operators to manage TF code.&lt;/li>
&lt;/ol>
&lt;p>When you sum it all up, you will notice that it is &lt;strong>all about autonomy&lt;/strong> and
&amp;ldquo;DevOps&amp;rdquo; through encouragement of self-service Ops. One wouldn&amp;rsquo;t need to know a
lot about Terraform to grab a module and pass some parameters to it, followed by
a code review process Operators and Software Developers can manage the
Infrastructure in harmony, &lt;strong>together&lt;/strong>. (:&lt;/p>
&lt;h3 id="code-exponentiation-what">Code Exponentiation? What?&lt;/h3>
&lt;p>Read that as a dramatization of the &lt;a href="https://en.wikipedia.org/wiki/Duplicate%5Fcode" target="_blank" rel="noopener">&amp;ldquo;code duplication&amp;rdquo;&lt;/a> term.&lt;/p>
&lt;p>When it comes to &lt;a href="https://macunha.me/en/category/infrastructure-as-code/">Infrastructure as Code&lt;/a>, there is no easy way around the jungle
of resources that grows over time. Fast pacing tech companies are &amp;ldquo;moving fast
and breaking things&amp;rdquo;, oftentimes the Operators are worried about a massive
amount of challenges at once: keep the servers up and running, with a consistent
response time, low error rate, and all that &lt;a href="https://sre.google/sre-book/table-of-contents/" target="_blank" rel="noopener">playbook from Google&amp;rsquo;s SRE wisdom&lt;/a>.&lt;/p>
&lt;p>All things considered, a good Infrastructure as Code design is generally
a first-world problem. However, as the time passes it evolves into a real issue
that slows down the implementation of resources as code. Either that or there
will be a &lt;strong>huge ton&lt;/strong> of copy+paste to keep up with the pace, followed by a
routine of find+replace when changes are applied, &lt;em>then&lt;/em> harder to track pull
requests and slower code reviews.&lt;/p>
&lt;p>Lets take our &lt;code>awesome_api&lt;/code> example and scale it up to multiple environments
followed by a second &lt;code>awesome_api&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">.
├── development
│   ├── an-awesome-api
│   │   └── main.tf
│   └── another-awesome-api
│   └── main.tf
├── staging
│   ├── an-awesome-api
│   │   └── main.tf
│   └── another-awesome-api
│   └── main.tf
└── production
├── an-awesome-api
│   └── main.tf
└── another-awesome-api
└── main.tf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note that this directory structure is inspired on the proposed ideas from the
&lt;a href="https://macunha.me/en/post/2021/03/terraform-design-best-practices/">Terraform best practices post&lt;/a>.&lt;/p>
&lt;p>In order to replicate the configuration and ensure consistency, the following is
way simpler to implement (and review) than copy+paste huge chunks of Terraform
definitions&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">module &lt;span style="color:#e6db74">&amp;#34;awesome_api&amp;#34;&lt;/span> {
source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;path/to/modules/organisms/aws_lambda_with_api_gateway&amp;#34;&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;~&amp;gt; 1.0&amp;#34;&lt;/span>
domain_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;record.example.com&amp;#34;&lt;/span>
zone_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;example.com.&amp;#34;&lt;/span>
lambda_functions &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>
&lt;span style="color:#75715e"># Index 0 -- An Awesome Lambda Function, used for POST&lt;/span>
{
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;an-awesome&amp;#34;&lt;/span>
description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;An Awesome lambda function for the Awesome API Gateway&amp;#34;&lt;/span>
handler &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;an_awesome.lambda_handler&amp;#34;&lt;/span>
runtime &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;python3.8&amp;#34;&lt;/span>
},
&lt;span style="color:#75715e"># Index 1 -- Another Awesome Lambda Function, used as $default&lt;/span>
{
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;another-awesome&amp;#34;&lt;/span>
description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Another Awesome lambda function for the Awesome API Gateway&amp;#34;&lt;/span>
handler &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;another_awesome.lambda_handler&amp;#34;&lt;/span>
runtime &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;python3.8&amp;#34;&lt;/span>
},
&lt;span style="color:#f92672">]&lt;/span>
api_gateway_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;awesome-api-gateway&amp;#34;&lt;/span>
api_gateway_description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;An Awesome API Gateway&amp;#34;&lt;/span>
api_gateway_integrations &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#e6db74">&amp;#34;POST /&amp;#34;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
lambda_function_index &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
payload_format_version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;2.0&amp;#34;&lt;/span>
}
&lt;span style="color:#e6db74">&amp;#34;$default&amp;#34;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
lambda_function_index &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>At the end of the day we get an ugly Terraform state containing many&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">module.something.module.something_else.module.yet_another_thing...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But the productivity boost gained by merging modules based on context is a worth
investment. Especially for huge Terraform repositories with multiple teams
collaborating and managing a lot of resources.&lt;/p>
&lt;p>Cross-team collaboration is fostered by applying the Atomic Design methodology
for Terraform modules, code reusability becomes an important factor over
copy+paste and the repository gravitates towards the &lt;a href="https://en.wikipedia.org/wiki/Don%27t%5Frepeat%5Fyourself" target="_blank" rel="noopener">DRY principle&lt;/a>.&lt;/p>
&lt;h2 id="same-post-different-places">Same post, different places&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.reddit.com/r/Terraform/comments/pd708z/terraform%5Fmodules%5Fatomic%5Fdesign/" target="_blank" rel="noopener">reddit.com: Terraform Modules: Atomic Design - r/Terraform&lt;/a>;&lt;/li>
&lt;li>&lt;a href="https://dev.to/macunha/terraform-modules-atomic-design-3i7m" target="_blank" rel="noopener">dev.to: Terraform Modules: Atomic Design - DEV Community&lt;/a>;&lt;/li>
&lt;li>&lt;a href="https://weekly.tf/issues/weekly-tf-issue-51-terraform-atomic-design-ec2-image-builder-736257" target="_blank" rel="noopener">weekly.tf: #51 - Terraform Atomic Design, EC2 Image Builder&lt;/a>;&lt;/li>
&lt;/ul></description></item><item><title>Terraform Design Best Practices</title><link>https://macunha.me/en/post/2021/03/terraform-design-best-practices/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0200</pubDate><guid>https://macunha.me/en/post/2021/03/terraform-design-best-practices/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>As someone who believes in empowering people and distributing power in order to
achieve higher outcomes I always felt that the best existing best-practices
proposals don&amp;rsquo;t touch some key aspects (IMHO) on code evolution and business
structures.&lt;/p>
&lt;p>Therefore, this document shall compose on the previous ones and extend them with
some self-service Ops and micro-services spice to the mix.&lt;/p>
&lt;p>On &lt;a href="https://www.terraform-best-practices.com" target="_blank" rel="noopener">Terraform best practices&lt;/a> great insights on how to write code inside a
module is provided, e.g. &lt;a href="https://www.terraform-best-practices.com/naming" target="_blank" rel="noopener">naming conventions&lt;/a>, &lt;a href="https://www.terraform-best-practices.com/code-structure#getting-started-with-structuring-of-terraform-configurations" target="_blank" rel="noopener">Terraform file naming&lt;/a>.&lt;/p>
&lt;p>We can&amp;rsquo;t leave Terragrunt epic blog post unmentioned:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.gruntwork.io/5-lessons-learned-from-writing-over-300-000-lines-of-infrastructure-code-36ba7fadeac1" target="_blank" rel="noopener">5 Lessons Learned From Writing Over 300,000 Lines of Infrastructure Code&lt;/a>;&lt;/li>
&lt;/ul>
&lt;p>As well as the &lt;a href="https://terragrunt.gruntwork.io/docs/getting-started/quick-start/#promote-immutable-versioned-terraform-modules-across-environments" target="_blank" rel="noopener">Terragrunt documentation pointing&lt;/a> &amp;ldquo;one of the most important
lessons&amp;rdquo; is that:&lt;/p>
&lt;blockquote>
&lt;p>large modules should be considered harmful. That is, it is a Bad Idea to define
all of your environments (dev, stage, prod, etc), or even a large amount of
infrastructure (servers, databases, load balancers, DNS, etc), in a single
Terraform module. Large modules are slow, insecure, hard to update, hard to code
review, hard to test, and brittle (i.e., you have all your eggs in one basket).&lt;/p>
&lt;/blockquote>
&lt;h3 id="bad-idea-capitalized">&amp;ldquo;Bad Idea&amp;rdquo; capitalized!&lt;/h3>
&lt;p>Which is totally true, as this &amp;ldquo;Bad Idea&amp;rdquo; usually coming from a lack of care
towards Terraform code design tend to be harmful in the long run, with a
tendency towards making the implementation a &lt;a href="https://en.wikipedia.org/wiki/Big%5Fball%5Fof%5Fmud" target="_blank" rel="noopener">big ball of mud&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>A Big Ball of Mud is a haphazardly structured, sprawling, sloppy,
duct-tape-and-baling-wire, spaghetti-code jungle. These systems show
unmistakable signs of unregulated growth, and repeated, expedient repair.
Information is shared promiscuously among distant elements of the system,
often to the point where nearly all the important information becomes global
or duplicated.&lt;/p>
&lt;/blockquote>
&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>The overall structure of the system may never have been well defined.&lt;/p>
&lt;/blockquote>
&lt;p>Oftentimes, Terraform code implementation fluctuate towards mono-repositories
(a.k.a. monorepos) containing all the specification in a single place. In order
to tame the chaos, the Terraform state needs to be at least sub-divided into
logical sections.&lt;/p>
&lt;h2 id="design">Design&lt;/h2>
&lt;h3 id="shallow-tree-of-shared-resources">Shallow &amp;ldquo;tree&amp;rdquo; of shared resources&lt;/h3>
&lt;p>Following the &lt;a href="https://www.terraform-best-practices.com/code-structure#common-recommendations-for-structuring-code" target="_blank" rel="noopener">recommendations for structuring code&lt;/a> one of the proposals is to
keep a shallow &amp;ldquo;tree&amp;rdquo; of resources and modules. This tree produces a small and
clear distribution of Terraform code.&lt;/p>
&lt;p>Why a shallow &amp;ldquo;tree&amp;rdquo; of resources? It helps achieving a short amount of
resources and modules that result in a small &lt;a href="https://www.terraform.io/docs/language/state/remote.html" target="_blank" rel="noopener">remote state&lt;/a> file. With a small
remote state we speed-up the development process and reduce waste (&lt;em>Muda&lt;/em> in the
Toyota 3M model), as the shallow tree enables faster executions of Terraform
(less data to sync and compare).&lt;/p>
&lt;p>The granularity level will be defined for each specific case (no silver bullet)
balancing the smallest and most feasible composition possible.&lt;/p>
&lt;h3 id="product-areas--a-dot-k-dot-a-dot-business-capabilities--structure-and-ownership">Product areas (a.k.a. Business capabilities) structure and ownership&lt;/h3>
&lt;p>Ideally, the &lt;a href="https://www.terraform-best-practices.com/key-concepts#composition" target="_blank" rel="noopener">composition level&lt;/a> would be organized around Product Areas (either
squads/crews or guilds) with a fallback to shared technologies (e.g. vpc,
databases). Therefore, Terraform compositions are designed around what Martin
Fowler &lt;a href="https://youtu.be/wgdBVIX9ifA?t=388" target="_blank" rel="noopener">calls &amp;ldquo;Business capabilities&amp;rdquo;&lt;/a> in micro-services terminology, ideally the
Terraform composition will follow the organizational structure so that each team
&amp;ldquo;owns&amp;rdquo; (in both senses: ownership and freedom) its own state.&lt;/p>
&lt;p>The main goal here is to structure the Terraform code as a reflection of the
organization so that is fosters self-service Ops. If the Infrastructure as Code
is mature enough to the point of having well-described Terraform modules,
everyone should be empowered to define these modules by setting the parameters
according to their needs, without centralizing power on a Operations team.&lt;/p>
&lt;p>The resource composition must gravitate towards the following (ordered by
priority from higher to lower):&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Product Areas (ownership) directory structure:&lt;/p>
&lt;ol>
&lt;li>squad/crew OR guild;&lt;/li>
&lt;li>product.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Shared resources, around technologies.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Looking on the structure from bottom-up it starts from the product and then
attributes the product to a crew through the directory tree.&lt;/p>
&lt;p>e.g.:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text"># Squad or Crew
red-team
└── payment # Product (i.e. micro-service) name
└── main.tf # Any resource used by the payment product
# Guild (organized around technology)
back-end
└─ monolith # Shared application in terms of ownership
   └── main.tf # Cloud resources used by the monolith
&lt;/code>&lt;/pre>&lt;/div>&lt;p>On the example above, we can&amp;rsquo;t ignore that &lt;code>monolith&lt;/code> is a product with shared
ownership among back-end developers and therefore it is organized to follow the
business structure.&lt;/p>
&lt;p>The structure is inspired &lt;a href="https://terragrunt.gruntwork.io/docs/getting-started/quick-start/#promote-immutable-versioned-terraform-modules-across-environments" target="_blank" rel="noopener">on Terragrunt&amp;rsquo;s best-practices&lt;/a> to some extend.
However, it distinct from Terragrunt proposal in the way resources are divided,
rather than organizing resources exclusively around technologies.&lt;/p>
&lt;h3 id="shared-resources-organized-around-technologies">Shared resources, organized around technologies&lt;/h3>
&lt;p>Oftentimes in organizations we will face shared resources among products, there
is no way around reality. e.g. a shared VPC or SQL database.&lt;/p>
&lt;p>However, these situations should be the exception and not the norm. Dealt
similar to the organization of Terraform compositions around
guilds/technologies.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">platform # as in Platform Engineering
└── vpc
└── main.tf
back-end
└── database
└── main.tf
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="files-inside-the-composition">Files inside the composition?&lt;/h3>
&lt;p>Ideally the files in the sub-directory (which specify the composition) are going
to partially &lt;a href="https://www.terraform-best-practices.com/code-structure#getting-started-with-structuring-of-terraform-configurations" target="_blank" rel="noopener">follow this spec&lt;/a> and include &lt;code>data.tf&lt;/code>, &lt;code>terraform.tf&lt;/code> and
&lt;code>providers.tf&lt;/code> on top of that.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>main.tf:&lt;/strong> contains locals, module and resource definitions;&lt;/li>
&lt;li>&lt;strong>variables.tf:&lt;/strong> contains declarations of variables (i.e. inputs/parameters)
used in main.tf;&lt;/li>
&lt;li>&lt;strong>data.tf:&lt;/strong> contains data-resources for input data used in main.tf;&lt;/li>
&lt;li>&lt;strong>outputs.tf:&lt;/strong> contains outputs from the resources created in main.tf;&lt;/li>
&lt;li>&lt;strong>providers.tf:&lt;/strong> contains provider and provider&amp;rsquo;s versions definitions;&lt;/li>
&lt;li>&lt;strong>terraform.tf:&lt;/strong> contains the terraform back-end (e.g. remote state)
definition;&lt;/li>
&lt;/ul>
&lt;h3 id="what-about-terraform-modules">What about Terraform modules?&lt;/h3>
&lt;p>&lt;a href="https://www.terraform.io/docs/language/modules/index.html" target="_blank" rel="noopener">Terraform modules&lt;/a> are containers for multiple resources that are used together
to achieve a shared goal. Modules can be used to create lightweight
abstractions, facilitating reusability and distribution of Terraform code.&lt;/p>
&lt;p>Therefore, we assume that the following are anti-patterns that make Terraform
modules' reusability difficult:&lt;/p>
&lt;ul>
&lt;li>Configuration of Terraform Providers inside a module;&lt;/li>
&lt;li>Implementation of Business logic and/or hard-coded parameters in a
module;&lt;/li>
&lt;li>Default values are specified in optional variables instead of
hard-coding;&lt;/li>
&lt;li>Modules should be self-contained and provide a clear contract.
Dependencies (pre-existing resources) must be specified through required
variables.&lt;/li>
&lt;li>Modules must serve to a singular purpose. Multiple purpose must be
achieved through composability of modules and not by &amp;ldquo;monolithic&amp;rdquo; modules.&lt;/li>
&lt;/ul>
&lt;p>Modules are abstractions that should be used to reduce the amount of code
duplication, implementing the &lt;a href="https://en.wikipedia.org/wiki/Don%27t%5Frepeat%5Fyourself" target="_blank" rel="noopener">DRY (don&amp;rsquo;t repeat yourself) principle&lt;/a>.&lt;/p>
&lt;p>On top of that, modules are an important factor to reduce the parity among
environments, which helps to better address the &lt;a href="https://12factor.net/" target="_blank" rel="noopener">Twelve-Factor App model&lt;/a> in
regards to &lt;a href="https://12factor.net/dev-prod-parity" target="_blank" rel="noopener">Factor X (ten)&lt;/a>.&lt;/p></description></item></channel></rss>